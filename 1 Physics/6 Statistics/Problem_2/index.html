<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 2 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 2";
        var mkdocs_page_input_path = "1 Physics/6 Statistics/Problem_2.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
</li>
</ul>
<p class="caption"><span class="caption-text">Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">Circuits</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../5%20Circuits/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">Statistics</a>
<ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 2</a>
<ul class="current">
<li class="toctree-l3"><a class="reference internal" href="#1-circle-based-monte-carlo-method">1. Circle-Based Monte Carlo Method</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#11-theoretical-background">1.1 Theoretical Background</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#12-convergence-analysis">1.2 Convergence Analysis</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#2-buffons-needle-method">2. Buffon's Needle Method</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#21-theoretical-background">2.1 Theoretical Background</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#22-convergence-analysis-for-buffons-needle">2.2 Convergence Analysis for Buffon's Needle</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#3-comparison-of-methods">3. Comparison of Methods</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#4-conclusions">4. Conclusions</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#5-applications">5. Applications</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">Physics</li>
<li class="breadcrumb-item">Statistics</li>
<li class="breadcrumb-item active">Problem 2</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-2">Problem 2</h1>
<p>Estimating π Using Monte Carlo Techniques</p>
<h2 id="1-circle-based-monte-carlo-method">1. Circle-Based Monte Carlo Method</h2>
<h3 id="11-theoretical-background">1.1 Theoretical Background</h3>
<p>The circle-based Monte Carlo method estimates the value of π by exploiting the geometric relationship between a circle and the square that surrounds it. For a unit circle (radius = 1) centered at the origin:</p>
<ul>
<li>Area of the circle: <span class="arithmatex">\( A_c = \pi r^2 = \pi \)</span></li>
<li>Area of the square: <span class="arithmatex">\( A_s = (2r)^2 = 4 \)</span></li>
</ul>
<p>The ratio of the circle’s area to the square’s area is:</p>
<div class="arithmatex">\[ \frac{A_c}{A_s} = \frac{\pi}{4} \]</div>
<p>Thus, π can be approximated as:</p>
<div class="arithmatex">\[ \pi \approx 4 \cdot \frac{\text{points falling inside the circle}}{\text{total number of points}} \]</div>
<p>Let’s implement this method in Python:</p>
<pre><code class="language-python"># Basic imports - no external dependencies
import numpy as np
import matplotlib.pyplot as plt

# Set random seed for reproducibility
np.random.seed(42)

def estimate_pi_circle(n_points):
    """
    Estimate π using the circle method.
    """
    # Generate random points
    x = np.random.uniform(-1, 1, n_points)
    y = np.random.uniform(-1, 1, n_points)

    # Calculate distances from origin
    distances = np.sqrt(x**2 + y**2)

    # Count points inside circle
    inside_circle = np.sum(distances &lt;= 1)

    # Estimate pi
    pi_estimate = 4 * inside_circle / n_points

    return pi_estimate, x, y, distances

def plot_circle_method():
    """
    Create visualization for the circle method with different sample sizes.
    """
    sample_sizes = [100, 1000, 10000]
    fig, axes = plt.subplots(1, 3, figsize=(20, 6))

    for i, n in enumerate(sample_sizes):
        pi_est, x, y, distances = estimate_pi_circle(n)

        # Plot points
        inside = distances &lt;= 1
        axes[i].scatter(x[inside], y[inside], c='blue', alpha=0.6, label='Inside')
        axes[i].scatter(x[~inside], y[~inside], c='red', alpha=0.6, label='Outside')

        # Draw circle
        theta = np.linspace(0, 2*np.pi, 100)
        axes[i].plot(np.cos(theta), np.sin(theta), 'k-')

        axes[i].set_aspect('equal')
        axes[i].grid(True)
        axes[i].set_title(f'n = {n}\nπ ≈ {pi_est:.6f}')
        axes[i].legend()
        axes[i].set_xlabel('x')
        axes[i].set_ylabel('y')

    plt.tight_layout()
    plt.show()

def simulate_buffon_needle(n_needles, L=1, D=2):
    """
    Simulate Buffon's needle experiment.
    """
    # Random positions and angles
    y = np.random.uniform(0, D, n_needles)
    theta = np.random.uniform(0, np.pi, n_needles)

    # Calculate needle endpoints
    y2 = y + L * np.sin(theta)

    # Count crossings
    crossings = np.sum(np.floor(y/D) != np.floor(y2/D))

    # Estimate pi
    pi_estimate = (2 * L * n_needles) / (D * crossings) if crossings &gt; 0 else np.inf

    return pi_estimate, y, theta

def plot_buffon_needles(n_needles=50):
    """
    Visualize Buffon's needle experiment.
    """
    L, D = 1, 2
    pi_est, y, theta = simulate_buffon_needle(n_needles, L, D)

    # Calculate needle endpoints
    x = np.zeros(n_needles)
    y1 = y
    x2 = L * np.cos(theta)
    y2 = y + L * np.sin(theta)

    plt.figure(figsize=(15, 8))

    # Draw parallel lines
    for i in range(-1, 4):
        plt.axhline(y=i*D, color='k', linestyle='--', alpha=0.3)

    # Draw needles
    for i in range(n_needles):
        crosses = np.floor(y1[i]/D) != np.floor(y2[i]/D)
        color = 'red' if crosses else 'blue'
        plt.plot([x[i], x2[i]], [y1[i], y2[i]], color=color, alpha=0.6,
                label='Crossing' if crosses and i == 0 else 'Not crossing' if not crosses and i == 0 else "")

    plt.title(f'Buffon\'s Needle Simulation (n={n_needles}, π ≈ {pi_est:.6f})')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.axis('equal')
    plt.grid(True)
    plt.legend()
    plt.show()

def compare_methods(max_points=5, steps=50):
    """
    Compare convergence of both methods.
    """
    points = np.logspace(2, max_points, steps, dtype=int)
    circle_errors = []
    buffon_errors = []

    for n in points:
        # Circle method
        pi_est_circle, _, _, _ = estimate_pi_circle(n)
        circle_errors.append(abs(pi_est_circle - np.pi))

        # Buffon's needle method
        pi_est_buffon, _, _ = simulate_buffon_needle(n)
        if pi_est_buffon != np.inf:
            buffon_errors.append(abs(pi_est_buffon - np.pi))
        else:
            buffon_errors.append(np.nan)

    plt.figure(figsize=(12, 8))
    plt.loglog(points, circle_errors, 'b-', label='Circle Method')
    plt.loglog(points, buffon_errors, 'r-', label='Buffon\'s Needle')
    plt.grid(True)
    plt.xlabel('Number of Points/Needles')
    plt.ylabel('Absolute Error')
    plt.title('Comparison of Method Convergence')
    plt.legend()
    plt.show()

# Run all simulations
print("Starting Monte Carlo π estimation...")

print("\nCircle Method Visualization:")
plot_circle_method()

print("\nBuffon's Needle Visualization:")
plot_buffon_needles()

print("\nMethod Comparison:")
compare_methods()

print("\nAll simulations completed!")
</code></pre>
<p><img alt="Circle Method Visualization" src="../images/problem%202.a1.PNG"/></p>
<p><img alt="Buffon's Needle Visualization" src="../images/problem%202.a2.PNG"/></p>
<p><img alt="Comparison of Methods" src="../images/problem%202.a3.PNG"/></p>
<h3 id="12-convergence-analysis">1.2 Convergence Analysis</h3>
<p>Let's analyze how the estimate converges as we increase the number of points:</p>
<pre><code class="language-python">def convergence_analysis(max_points, steps):
    points = np.logspace(2, max_points, steps, dtype=int)
    estimates = []
    errors = []

    for n in points:
        pi_est, _, _, _ = estimate_pi_circle(n)
        estimates.append(pi_est)
        errors.append(abs(pi_est - np.pi))

    return points, estimates, errors

# Perform analysis
points, estimates, errors = convergence_analysis(5, 50)

# Plot results
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))

# Estimates plot
ax1.semilogx(points, estimates, 'b-', label='Estimate')
ax1.axhline(y=np.pi, color='r', linestyle='--', label='True π')
ax1.grid(True)
ax1.set_xlabel('Number of Points')
ax1.set_ylabel('π Estimate')
ax1.legend()
ax1.set_title('Convergence of π Estimate')

# Error plot
ax2.loglog(points, errors, 'g-')
ax2.grid(True)
ax2.set_xlabel('Number of Points')
ax2.set_ylabel('Absolute Error')
ax2.set_title('Error vs. Number of Points')
plt.tight_layout()
plt.show()
</code></pre>
<p><img alt="Convergence Analysis" src="../images/problem%202.a4.PNG"/></p>
<h2 id="2-buffons-needle-method">2. Buffon's Needle Method</h2>
<h3 id="21-theoretical-background">2.1 Theoretical Background</h3>
<p>Buffon's Needle problem involves randomly dropping needles of length <span class="arithmatex">\( L \)</span> onto a surface marked with parallel lines spaced <span class="arithmatex">\( D \)</span> units apart. The probability that a needle crosses one of the lines is given by:</p>
<div class="arithmatex">\[ P(\text{crossing}) = \frac{2L}{\pi D} \]</div>
<p>From this relationship, we can estimate π using the formula:</p>
<div class="arithmatex">\[ \pi \approx \frac{2L}{D} \cdot \frac{\text{total drops}}{\text{number of crossings}} \]</div>
<p>Let’s implement this technique:</p>
<pre><code class="language-python">def simulate_buffon_needle(n_needles, L=1, D=2):
    # Random positions and angles
    y = np.random.uniform(0, D, n_needles)
    theta = np.random.uniform(0, np.pi, n_needles)

    # Calculate needle endpoints
    y2 = y + L * np.sin(theta)

    # Count crossings
    crossings = np.sum(np.floor(y/D) != np.floor(y2/D))

    # Estimate pi
    pi_estimate = (2 * L * n_needles) / (D * crossings) if crossings &gt; 0 else np.inf

    return pi_estimate, y, theta

def plot_buffon_needles(n_needles=50):
    L, D = 1, 2
    pi_est, y, theta = simulate_buffon_needle(n_needles, L, D)

    # Calculate needle endpoints
    x = np.zeros(n_needles)
    y1 = y
    x2 = L * np.cos(theta)
    y2 = y + L * np.sin(theta)

    # Plot
    plt.figure(figsize=(12, 6))

    # Draw parallel lines
    for i in range(-1, 4):
        plt.axhline(y=i*D, color='k', linestyle='--', alpha=0.3)

    # Draw needles
    for i in range(n_needles):
        crosses = np.floor(y1[i]/D) != np.floor(y2[i]/D)
        color = 'red' if crosses else 'blue'
        plt.plot([x[i], x2[i]], [y1[i], y2[i]], color=color, alpha=0.6)

    plt.title(f'Buffon\'s Needle Simulation (n={n_needles}, π ≈ {pi_est:.6f})')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.axis('equal')
    plt.grid(True)
    plt.show()

# Visualize Buffon's needle simulation
plot_buffon_needles(50)
</code></pre>
<p><img alt="Buffon's Needle Simulation" src="../images/problem%202.a5.PNG"/></p>
<h3 id="22-convergence-analysis-for-buffons-needle">2.2 Convergence Analysis for Buffon's Needle</h3>
<p>Let's analyze the convergence of the Buffon's needle method:</p>
<pre><code class="language-python">def buffon_convergence_analysis(max_points, steps):
    points = np.logspace(2, max_points, steps, dtype=int)
    estimates = []
    errors = []

    for n in points:
        pi_est, _, _ = simulate_buffon_needle(n)
        if pi_est != np.inf:
            estimates.append(pi_est)
            errors.append(abs(pi_est - np.pi))
        else:
            estimates.append(np.nan)
            errors.append(np.nan)

    return points, estimates, errors

# Perform analysis
points, estimates, errors = buffon_convergence_analysis(5, 50)

# Plot results
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))

# Estimates plot
ax1.semilogx(points, estimates, 'b-', label='Estimate')
ax1.axhline(y=np.pi, color='r', linestyle='--', label='True π')
ax1.grid(True)
ax1.set_xlabel('Number of Needles')
ax1.set_ylabel('π Estimate')
ax1.legend()
ax1.set_title('Convergence of Buffon\'s Needle Method')

# Error plot
ax2.loglog(points, errors, 'g-')
ax2.grid(True)
ax2.set_xlabel('Number of Needles')
ax2.set_ylabel('Absolute Error')
ax2.set_title('Error vs. Number of Needles')

plt.tight_layout()
plt.show()
</code></pre>
<p><img alt="Buffon's Needle Convergence Analysis" src="assets/prob2_a6.png"/></p>
<h2 id="3-comparison-of-methods">3. Comparison of Methods</h2>
<p>Let's compare the convergence rates of both methods:</p>
<pre><code class="language-python">def compare_methods(max_points=5, steps=50):
    points = np.logspace(2, max_points, steps, dtype=int)
    circle_errors = []
    buffon_errors = []

    for n in points:
        # Circle method
        pi_est_circle, _, _, _ = estimate_pi_circle(n)
        circle_errors.append(abs(pi_est_circle - np.pi))

        # Buffon's needle method
        pi_est_buffon, _, _ = simulate_buffon_needle(n)
        if pi_est_buffon != np.inf:
            buffon_errors.append(abs(pi_est_buffon - np.pi))
        else:
            buffon_errors.append(np.nan)

    plt.figure(figsize=(10, 6))
    plt.loglog(points, circle_errors, 'b-', label='Circle Method')
    plt.loglog(points, buffon_errors, 'r-', label='Buffon\'s Needle')
    plt.grid(True)
    plt.xlabel('Number of Points/Needles')
    plt.ylabel('Absolute Error')
    plt.title('Comparison of Method Convergence')
    plt.legend()
    plt.show()

compare_methods()
</code></pre>
<p><img alt="Comparison of Methods" src="../images/problem%202.a7.PNG"/></p>
<h2 id="4-conclusions">4. Conclusions</h2>
<ol>
<li>
<p><strong>Convergence Rate</strong></p>
<ul>
<li>The circle-based method tends to exhibit more consistent convergence</li>
<li>Buffon's needle method shows greater variability in its estimates</li>
</ul>
</li>
<li>
<p><strong>Computational Efficiency</strong></p>
<ul>
<li>The circle method is easier to implement and requires fewer computations</li>
<li>Buffon's needle involves more intricate geometric processing</li>
</ul>
</li>
<li>
<p><strong>Practical Considerations</strong></p>
<ul>
<li>Both methods effectively illustrate the power of Monte Carlo approaches</li>
<li>The circle method is particularly well-suited for educational settings</li>
<li>Buffon's needle adds historical significance and geometric insight</li>
</ul>
</li>
</ol>
<h2 id="5-applications">5. Applications</h2>
<ul>
<li>Testing the quality of random number generators  </li>
<li>Introducing the fundamentals of Monte Carlo techniques  </li>
<li>Teaching key ideas in probability and geometry  </li>
<li>Demonstrating the law of large numbers in practice  </li>
</ul>
<p>Estimating π using Monte Carlo methods offers a clear and engaging way to introduce computational techniques in both physics and mathematics, highlighting how randomness can be harnessed to solve deterministic problems.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../7%20Measurements/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../7%20Measurements/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
